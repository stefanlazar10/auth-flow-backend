"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEntityByRepository = exports.getCustomRepositoryToken = void 0;
const typeorm_1 = require("typeorm");
const custom_repository_constants_1 = require("../custom-repository.constants");
function getCustomRepositoryToken(repository, dataSource = custom_repository_constants_1.DEFAULT_CONNECTION_NAME) {
    if (!repository) {
        throw new Error('repository is not empty');
    }
    const connectionPrefix = getDataSourcePrefix(dataSource);
    if (repository instanceof Function && repository.prototype instanceof typeorm_1.Repository) {
        if (!connectionPrefix) {
            return repository;
        }
        return `${connectionPrefix}${getToken(repository)}`;
    }
    return `${connectionPrefix}${repository.name}Repository`;
}
exports.getCustomRepositoryToken = getCustomRepositoryToken;
function getEntityByRepository(repository) {
    const entity = Reflect.getMetadata(custom_repository_constants_1.ENTITY_METADATA_KEY, repository);
    if (!entity) {
        throw new Error(`Repository: ${repository.name} undetermined entity`);
    }
    return entity;
}
exports.getEntityByRepository = getEntityByRepository;
function getToken(repository) {
    return repository.name;
}
function getDataSourcePrefix(dataSource = custom_repository_constants_1.DEFAULT_CONNECTION_NAME) {
    if (dataSource === custom_repository_constants_1.DEFAULT_CONNECTION_NAME) {
        return '';
    }
    if (typeof dataSource === 'string') {
        return dataSource + '_';
    }
    if (dataSource.name === custom_repository_constants_1.DEFAULT_CONNECTION_NAME || !dataSource.name) {
        return '';
    }
    return dataSource.name + '_';
}
